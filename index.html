<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#FF69B4" />
    <title>decrypt-event</title>
    <style>
      body {
        color : yellow;
        background-color: rgb(0, 0, 99);
      }
      #root{
        height: 50vh;
        width: 100vw;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      #decrypted{
        width: 100vw;
        display: flex;
        overflow: scroll;
      }
      label, input, textarea {
        display: block;
        width: 600px;
      }

    </style>
  </head>
  <body>
    <div id="root">
      <form action="" id="form">
          <label for="email">email</label>
          <input type="text" id="email" name="email" aria-required="true" ></input>

          <label for="password">password</label>
          <input type="password" id="password" name="password" aria-required="true"></input>

          <label for="domainEventId">event_id</label>
          <input type="text" id="domainEventId" name="domainEventId" aria-required="true"></input>

        <input type="submit" value="decrypt !">
      </form>

    </div>
    <div id='decrypted'></div>
  </body>
  <script>(()=>{"use strict";const e=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,t=["user","credentials"];class r{constructor(e,t){this.user_id=e,this.api=t}async pull(e){var t;return null!==(t=(await this.pullAll())[e])&&void 0!==t?t:null}async pullAll(){return(await this.api.getUserDevices(this.user_id)).reduce(((r,{name:s})=>{try{const a=JSON.parse(s);n=a,Array.isArray(n)&&2===n.length&&t.includes(n[0])&&e.test(n[1])&&(r[a[0]]=a[1])}catch(e){console.log(`ApiKeyRepo ignored "${s}" because it is using /api/device to exchange keys as part of a concurrency issue workaround.`)}var n;return r}),{})}async push(e,t){const r=JSON.stringify([e,t]),{new_id:s}=await this.api.createDevice({name:r,type:"mobile",user_id:this.user_id});if(!s)throw new Error(`/api/device did not accept : ${r} for user_id ${this.user_id} !`);return t}}class s extends Error{constructor(e){super(e),this.name="CoreServerError"}}class n extends Error{constructor(e){super(e),this.name="NetworkError"}}function a(e){this.message=e}Error,a.prototype=new Error,a.prototype.name="InvalidCharacterError";var i="undefined"!=typeof window&&window.atob&&window.atob.bind(window)||function(e){var t=String(e).replace(/=+$/,"");if(t.length%4==1)throw new a("'atob' failed: The string to be decoded is not correctly encoded.");for(var r,s,n=0,i=0,o="";s=t.charAt(i++);~s&&(r=n%4?64*r+s:s,n++%4)?o+=String.fromCharCode(255&r>>(-2*n&6)):0)s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(s);return o};function o(e){var t=e.replace(/-/g,"+").replace(/_/g,"/");switch(t.length%4){case 0:break;case 2:t+="==";break;case 3:t+="=";break;default:throw"Illegal base64url string!"}try{return function(e){return decodeURIComponent(i(e).replace(/(.)/g,(function(e,t){var r=t.charCodeAt(0).toString(16).toUpperCase();return r.length<2&&(r="0"+r),"%"+r})))}(t)}catch(e){return i(t)}}function c(e){this.message=e}c.prototype=new Error,c.prototype.name="InvalidTokenError";const l=function(e,t){if("string"!=typeof e)throw new c("Invalid token specified");var r=!0===(t=t||{}).header?0:1;try{return JSON.parse(o(e.split(".")[r]))}catch(e){throw new c("Invalid token specified: "+e.message)}};class h extends Error{constructor(){super("Invalid credentials"),this.name="InvalidCredentialsLoginError"}}class y{async get(e){return null}async getAll(){return{}}async put(e,t){return t}}class u extends Error{constructor(e){super(`Underlying cryptography API is not available${e?" to use in "+e:""} !`),this.actor=e,this.name="UnavailableCryptoApiError"}}const d=12,w=16,p="AES-GCM",g=new TextEncoder,m=new TextDecoder;function f(e){const t=[],r=e.byteLength;for(let s=0;s<r;s+=16384)t.push(String.fromCharCode.apply(String,e.subarray(s,s+16384)));return t.join("")}const v={isAvailable(){var e;return!!(null===(e=null===window||void 0===window?void 0:window.crypto)||void 0===e?void 0:e.subtle)&&"function"==typeof window.crypto.getRandomValues},async getStopGapPasswordHash(e,t){const[r]=await v.deriveKeyFrom(e,{salt:g.encode("__UNIPILE_APP_"+t),extractable:!0}),s=new Uint8Array(await window.crypto.subtle.exportKey("raw",r));return btoa(f(s))},getKeyMaterial:async e=>window.crypto.subtle.importKey("raw",g.encode(e),"PBKDF2",!1,["deriveKey"]),async deriveKeyFrom(e,{salt:t=window.crypto.getRandomValues(new Uint8Array(w)),iterations:r=25e4,extractable:s=!1,algo:n=p,keyUsages:a=["encrypt","decrypt"]}={}){const i=await v.getKeyMaterial(e);return[await window.crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:r,hash:"SHA-256"},i,{name:n,length:256},s,a),t]},generateKey:async(e=p,t=!0,r=["encrypt","decrypt"])=>window.crypto.subtle.generateKey({name:e,length:256},t,r),async wrap(e,t){const[r,s]=await v.deriveKeyFrom(e,{algo:"AES-GCM",keyUsages:["wrapKey"]}),n=window.crypto.getRandomValues(new Uint8Array(d)),a=new Uint8Array(await window.crypto.subtle.wrapKey("raw",t,r,{name:"AES-GCM",iv:n})),i=new Uint8Array(28+a.byteLength);return i.set(s,0),i.set(n,w),i.set(a,28),btoa(f(i))},async unwrap(e,t){const r=atob(t),s=new Uint8Array(r.length);for(let e=0,t=r.length;e<t;++e)s[e]=r.charCodeAt(e);const n=s.subarray(0,w),a=s.subarray(w,28),i=s.subarray(28),[o]=await v.deriveKeyFrom(e,{algo:"AES-GCM",keyUsages:["unwrapKey"],salt:n});return window.crypto.subtle.unwrapKey("raw",i,o,{name:"AES-GCM",iv:a},{name:p,length:256},!0,["encrypt","decrypt"])},async encrypt(e,t){const r=window.crypto.getRandomValues(new Uint8Array(d)),s=new Uint8Array(await window.crypto.subtle.encrypt({name:p,iv:r},e,g.encode(t))),n=new Uint8Array(d+s.byteLength);return n.set(r,0),n.set(s,d),btoa(f(n))},async decrypt(e,t){const r=atob(t),s=new Uint8Array(r.length);for(let e=0,t=r.length;e<t;++e)s[e]=r.charCodeAt(e);const n=s.subarray(0,d),a=s.subarray(d),i=await window.crypto.subtle.decrypt({name:p,iv:n},e,a);return m.decode(i)},async encryptWithPassword(e,t){const[r,s]=await v.deriveKeyFrom(e),n=window.crypto.getRandomValues(new Uint8Array(d)),a=new Uint8Array(await window.crypto.subtle.encrypt({name:p,iv:n},r,g.encode(t))),i=new Uint8Array(28+a.byteLength);return i.set(s,0),i.set(n,w),i.set(a,28),btoa(f(i))},async decryptWithPassword(e,t){const r=atob(t),s=new Uint8Array(r.length);for(let e=0,t=r.length;e<t;++e)s[e]=r.charCodeAt(e);const n=s.subarray(0,w),a=s.subarray(w,28),i=s.subarray(28),[o]=await v.deriveKeyFrom(e,{salt:n}),c=await window.crypto.subtle.decrypt({name:p,iv:a},o,i);return m.decode(c)}};class b{constructor(e,r,s,n,a){this.password=r,this.keyStore=s,this.keyRepo=n,this.crypto=a,this.keys=t.reduce(((e,t)=>(e[t]=null,e)),{}),this.keys.user=e}static async create(e,t,r,s=v){if(!s.isAvailable())throw new u(this.name);let n=await t.get("user");n||(n=await r.pull("user"),n?await t.put("user",n):n=(await b.renewKey(e,"user",t,r,s))[1]);try{const a=await s.unwrap(e,n);return new b(a,e,t,r,s)}catch(e){throw console.log("Original error :",e),new _("KeychainService")}}static async renewKey(e,t,r,s,n){const a=await n.generateKey(),i=await n.wrap(e,a);try{return await s.push(t,i),await r.put(t,i),[a,i]}catch(e){throw console.log("Original error :",e),console.log("@todo : Retry/handle local keyStore.put errors !"),new E(t,"KeychainService")}}async get(e){if(this.keys[e])return this.keys[e];let t=await this.keyStore.get(e);return t||(t=await this.keyRepo.pull(e),t&&await this.keyStore.put(e,t)),this.keys[e]=t?await this.crypto.unwrap(this.password,t):(await b.renewKey(this.password,e,this.keyStore,this.keyRepo,this.crypto))[0]}async export(){return this.keyStore.getAll()}async import(e){return Promise.all(Object.entries(e).map((([e,t])=>this.keyStore.put(e,t))))}async shred(e){const[t,r]=await b.renewKey(this.password,e,this.keyStore,this.keyRepo,this.crypto);return this.keys[e]=t,r}}class _ extends Error{constructor(e){super(`Invalid password${e?" to unlock "+e:""} !`),this.actor=e,this.name="InvalidPasswordError"}}Error;class E extends Error{constructor(e,t){super(`Could not create ${e} key ${t?" in "+t:""} because app is offline or server errored !`),this.topic=e,this.actor=t,this.name="KeyCannotBeCreatedError"}}function S(e){return"object"==typeof e&&null!==e}const k={host:"https://core.unipile.com"},A=new class{constructor(){this.saved_session=null,this.password=null}async set(e,t){this.saved_session=e}async get(){return this.saved_session}async getPassword(){return this.password}async delete(){this.saved_session=null}},O=new class{constructor(e,t,r){this.config=e,this.sessionRepo=t,this.crypto=r,this.jwt=null}async login(e,t){const r=await this.crypto.getStopGapPasswordHash(t,e),n=await fetch(`${this.config.host}/api/login_check`,{headers:{"Content-Type":"application/json"},method:"POST",body:JSON.stringify({username:e,password:r})});let a;try{a=await n.json()}catch(e){throw new s(n.statusText)}if(!n.ok||!a.refresh_token||!a.token){if("Invalid credentials."===a.message)throw new h;throw new Error(a.message?a.message:a)}const{refresh_token:i,token:o}=a;this.jwt=o,await this._saveSession(i,o,t)}async getJwt(){return this._isJwtExpired()&&await this._refreshToken(),this.jwt||null}async logout(){await this.sessionRepo.delete(),this.jwt=null}async _refreshToken(){if(!this._isJwtExpired())return;const e=await this.sessionRepo.get();if(!e)throw new Error("You must be logged in to refresh the session");const t=await fetch(`${this.config.host}/api/token/refresh`,{headers:{"Content-Type":"application/json"},method:"POST",body:JSON.stringify({refresh_token:e.refresh_token})});let r;try{r=await t.json()}catch(e){throw new Error(t.statusText)}if(!t.ok||!r.refresh_token||!r.token)throw new Error(r.message?r.message:r);const{refresh_token:s,token:n}=r;this.jwt=n,await this.sessionRepo.set(Object.assign(Object.assign({},e),{refresh_token:s}))}_isJwtExpired(){return!this.jwt||l(this.jwt).exp<Math.floor(Date.now()/1e3)}_buildSession(e,t){const r=l(t);return r.params===[]&&(r.params={}),{refresh_token:e,user_id:r.id,lastname:r.lastname,firstname:r.firstname,email:r.email,params:r.params,profile_picture:r.thumbnail_picture,language:r.language}}async _saveSession(e,t,r){const s=this._buildSession(e,t);await this.sessionRepo.set(s,r)}}(k,A,v),C=new class{constructor(e,t){this.config=e,this.authenticator=t}async _fetch(e,t){const r=Object.assign(Object.assign({},t),{headers:Object.assign({"Content-Type":"application/json"},null==t?void 0:t.headers)});let a,i;try{a=await fetch(this.config.host+e,r)}catch(e){if(e instanceof TypeError)throw new n(e.message);throw e}try{i=await a.json()}catch(e){throw new s(a.statusText)}if(!a.ok){const e=new Error(i.toString());throw e.name=i.title?i.title:"CoreClientError",e}return i}async _fetchAuth(e,t){const r=await this.authenticator.getJwt();if(!r)throw new Error("You must be logged in to access a protected route");const s=Object.assign(Object.assign({},t),{headers:Object.assign({Authorization:`Bearer ${r}`},null==t?void 0:t.headers)});return this._fetch(e,s)}async getAdminLink(){return(await this._fetchAuth("/api/security/link")).url}async registerUser(e,t,r,s,n){return this._fetch("/api/user/registration",{method:"POST",body:JSON.stringify({firstname:r,lastname:s,email:e,password:t,referral_code:n})})}async getUser(e){return this._fetchAuth(`/api/user/${e}`)}async updateUser(e,t){return this._fetchAuth(`/api/user/${t}`,{method:"PUT",body:JSON.stringify(e)})}async getDomainEvents(e,t=0,r=100){return this._fetchAuth("/api/domainevent/list",{method:"POST",body:JSON.stringify({user_id:e,from_id:t,limit:r})})}async deleteDomainEvents(e,t,r){return this._fetchAuth("/api/domainevent",{method:"DELETE",body:JSON.stringify({user_id:e,from_id:t,to_id:r})})}async resetDomainEvents(e){return this._fetchAuth("/api/domainevent/reset",{method:"DELETE",body:JSON.stringify({user_id:e})})}async pushDomainEvents(e){if(e.length)return this._fetchAuth("/api/domainevent/create_many",{method:"POST",body:JSON.stringify({user_id:e[0].user_id,values:e.map((e=>e.content))})});throw new Error("Unsupported call to CoreApiService.pushDomainEvents with empty events array.")}async createDevice(e){return this._fetchAuth("/api/device",{method:"POST",body:JSON.stringify(e)})}async getUserDevices(e){return this._fetchAuth(`/api/user/${e}/device`)}}(k,O),K=document.getElementById("form");null==K||K.addEventListener("submit",(e=>{var t;e.preventDefault(),console.log(">>> submit");const s=new FormData(e.target),n=s.get("email"),a=s.get("password"),i=+(null!==(t=s.get("domainEventId"))&&void 0!==t?t:0);n&&"string"==typeof n&&a&&"string"==typeof a&&i&&"number"==typeof i&&!isNaN(i)?async function(e,t,s){try{await O.login(e,t);const n=await A.get();if(!n)return void window.alert("Login failed.\nHit F5 to try again.");const[a]=await C.getDomainEvents(n.user_id,s,1),i=await b.create(t,new y,new r(null==n?void 0:n.user_id,C),v),o=await i.get("user");try{const e=await v.decrypt(o,a.content);console.log(JSON.stringify(JSON.parse(e),null,2));const t=document.getElementById("decrypted"),r=document.createElement("pre");r.textContent=JSON.stringify(JSON.parse(e),null,2),null==t||t.appendChild(r)}catch(e){window.alert(`Decryption failed : ${S(e)&&"message"in e?e.message:JSON.stringify(e)}\nHit F5 to try again.`)}}catch(e){window.alert(`Login failed : ${S(e)&&"message"in e?e.message:JSON.stringify(e)}\nHit F5 to try again.`)}}(n,a,i):(console.log(n,a,i),window.alert("Some fields are missing or invalid, try again."))}))})();</script>
</html>
